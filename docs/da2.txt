## 2nd attempt
@abstractmethod
    async def process(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"
        Process input data and return results.
        Must be implemented by each agent.
        \"\"\"
        pass

    async def _update_status(self, status: str, progress: int = None):
        \"\"\"Update agent status in database and log.\"\"\"
        self.status = status
        if progress is not None:
            self.progress = progress

        # Update database
        if self.current_project_id:
            await self.database.update_agent_status(
                project_id=self.current_project_id,
                agent_type=self.agent_type,
                status=status,
                progress=self.progress
            )

        # Log status change
        self.logger.info(f\"{self.agent_type} agent status: {status} ({self.progress}%)\")

    async def _handle_error(self, error_message: str):
        \"\"\"Handle agent errors with logging and status update.\"\"\"
        self.logger.error(f\"{self.agent_type} agent error: {error_message}\")
        await self._update_status(\"error\", self.progress)

        # Save error to database
        if self.current_project_id:
            await self.database.log_agent_error(
                project_id=self.current_project_id,
                agent_type=self.agent_type,
                error_message=error_message
            )

    async def _send_message(self, to_agent: str, content: Dict[str, Any]):
        \"\"\"Send message to another agent through the message queue.\"\"\"
        message_id = await self.database.create_message(
            project_id=self.current_project_id,
            from_agent=self.agent_type,
            to_agent=to_agent,
            content=content
        )

        self.logger.info(f\"Message sent from {self.agent_type} to {to_agent}: {message_id}\")
        return message_id

    async def _validate_input(self, input_data: Dict[str, Any], required_fields: list) -> bool:
        \"\"\"Validate that input data contains required fields.\"\"\"
        missing_fields = [field for field in required_fields if field not in input_data]

        if missing_fields:
            error_msg = f\"Missing required fields: {missing_fields}\"
            await self._handle_error(error_msg)
            return False

        return True

    def _start_processing(self, project_id: str):
        \"\"\"Initialize processing tracking.\"\"\"
        self.current_project_id = project_id
        self.start_time = time.time()
        self.status = \"processing\"
        self.progress = 0

    def _finish_processing(self):
        \"\"\"Finalize processing tracking.\"\"\"
        if self.start_time:
            self.processing_time = time.time() - self.start_time
        self.status = \"completed\"
        self.progress = 100

    def get_status(self) -> Dict[str, Any]:
        \"\"\"Get current agent status.\"\"\"
        return {
            \"agent_type\": self.agent_type,
            \"status\": self.status,
            \"progress\": self.progress,
            \"processing_time\": self.processing_time,
            \"project_id\": self.current_project_id
        }
'''

    async def _generate_react_app(self) -> str:
        \"\"\"Generate main React App component.\"\"\"

        return '''import React from 'react';
import { AppProvider } from './context/AppContext';
import Dashboard from './components/Dashboard';
import './App.css';

function App() {
  return (
    <AppProvider>
      <div className=\"App min-h-screen bg-gray-50\">
        <Dashboard />
      </div>
    </AppProvider>
  );
}

export default App;
'''

    async def _generate_app_context(self) -> str:
        \"\"\"Generate React context for state management.\"\"\"

        return '''import React, { createContext, useContext, useState, useEffect } from 'react';

const AppContext = createContext();

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};

export const AppProvider = ({ children }) => {
  // Main application state
  const [project, setProject] = useState({
    id: null,
    requirements: '',
    status: 'idle',
    createdAt: null
  });

  const [agents, setAgents] = useState({
    analyst: { status: 'idle', progress: 0, messages: [] },
    architect: { status: 'idle', progress: 0, messages: [] },
    developer: { status: 'idle', progress: 0, messages: [] },
    tester: { status: 'idle', progress: 0, messages: [] }
  });

  const [actionQueue, setActionQueue] = useState([]);
  const [files, setFiles] = useState({ generated: [], uploads: [] });
  const [systemStatus, setSystemStatus] = useState({
    connected: false,
    performance: { cpu: 0, memory: 0 },
    tokenUsage: { total: 0, cost: 0 }
  });

  // Server-Sent Events connection
  useEffect(() => {
    const eventSource = new EventSource('/api/stream');

    eventSource.onopen = () => {
      setSystemStatus(prev => ({ ...prev, connected: true }));
    };

    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handleRealtimeUpdate(data);
      } catch (error) {
        console.error('Error parsing SSE data:', error);
      }
    };

    eventSource.onerror = () => {
      setSystemStatus(prev => ({ ...prev, connected: false }));
    };

    return () => {
      eventSource.close();
    };
  }, []);

  // Handle real-time updates from backend
  const handleRealtimeUpdate = (data) => {
    switch (data.type) {
      case 'agent_status':
        setAgents(prev => ({
          ...prev,
          [data.agent]: {
            ...prev[data.agent],
            status: data.status,
            progress: data.progress
          }
        }));
        break;

      case 'message_new':
        setAgents(prev => ({
          ...prev,
          [data.agent]: {
            ...prev[data.agent],
            messages: [...prev[data.agent].messages, data.message]
          }
        }));
        break;

      case 'conflict_detected':
        setActionQueue(prev => [...prev, {
          id: data.id,
          type: 'conflict',
          description: data.description,
          timestamp: new Date(),
          resolved: false
        }]);
        break;

      case 'project_complete':
        setProject(prev => ({ ...prev, status: 'completed' }));
        setFiles(prev => ({ ...prev, generated: data.files }));
        break;

      default:
        console.log('Unknown event type:', data.type);
    }
  };

  // API functions
  const startProject = async (requirements) => {
    try {
      const response = await fetch('/api/projects', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ requirements })
      });

      const data = await response.json();
      setProject({
        id: data.project_id,
        requirements,
        status: 'processing',
        createdAt: new Date()
      });

      return data;
    } catch (error) {
      console.error('Error starting project:', error);
      throw error;
    }
  };

  const resolveAction = async (actionId, resolution) => {
    try {
      await fetch('/api/conflicts/resolve', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action_id: actionId, resolution })
      });

      setActionQueue(prev => 
        prev.map(action => 
          action.id === actionId 
            ? { ...action, resolved: true, resolution }
            : action
        )
      );
    } catch (error) {
      console.error('Error resolving action:', error);
      throw error;
    }
  };

  const value = {
    // State
    project,
    agents,
    actionQueue,
    files,
    systemStatus,

    // Actions
    startProject,
    resolveAction,
    setProject,
    setAgents,
    setActionQueue,
    setFiles
  };

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};
'''`,
      `oldText`: `    @abstractmethod
    async def process(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        \"\"\"
        Process input data and return results.`
    },
    {
      `newText`: `        \"\"\"`
    }
  ]
}