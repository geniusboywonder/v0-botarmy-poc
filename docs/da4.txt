## 4th attempt
{
  `content`: `        if missing_fields:
            error_msg = f\"Missing required fields: {missing_fields}\"
            await self._handle_error(error_msg)
            return False

        return True

    def _start_processing(self, project_id: str):
        \"\"\"Initialize processing tracking.\"\"\"
        self.current_project_id = project_id
        self.start_time = time.time()
        self.status = \"processing\"
        self.progress = 0

    def _finish_processing(self):
        \"\"\"Finalize processing tracking.\"\"\"
        if self.start_time:
            self.processing_time = time.time() - self.start_time
        self.status = \"completed\"
        self.progress = 100

    def get_status(self) -> Dict[str, Any]:
        \"\"\"Get current agent status.\"\"\"
        return {
            \"agent_type\": self.agent_type,
            \"status\": self.status,
            \"progress\": self.progress,
            \"processing_time\": self.processing_time,
            \"project_id\": self.current_project_id
        }
'''

    async def _generate_react_app(self) -> str:
        \"\"\"Generate main React App component.\"\"\"

        return '''import React from 'react';
import { AppProvider } from './context/AppContext';
import Dashboard from './components/Dashboard';
import './App.css';

function App() {
  return (
    <AppProvider>
      <div className=\"App min-h-screen bg-gray-50\">
        <Dashboard />
      </div>
    </AppProvider>
  );
}

export default App;
'''

    async def _generate_app_context(self) -> str:
        \"\"\"Generate React context for state management.\"\"\"

        return '''import React, { createContext, useContext, useState, useEffect } from 'react';

const AppContext = createContext();

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};

export const AppProvider = ({ children }) => {
  // Main application state
  const [project, setProject] = useState({
    id: null,
    requirements: '',
    status: 'idle',
    createdAt: null
  });

  const [agents, setAgents] = useState({
    analyst: { status: 'idle', progress: 0, messages: [] },
    architect: { status: 'idle', progress: 0, messages: [] },
    developer: { status: 'idle', progress: 0, messages: [] },
    tester: { status: 'idle', progress: 0, messages: [] }
  });

  const [actionQueue, setActionQueue] = useState([]);
  const [files, setFiles] = useState({ generated: [], uploads: [] });
  const [systemStatus, setSystemStatus] = useState({
    connected: false,
    performance: { cpu: 0, memory: 0 },
    tokenUsage: { total: 0, cost: 0 }
  });

  // Server-Sent Events connection
  useEffect(() => {
    const eventSource = new EventSource('/api/stream');

    eventSource.onopen = () => {
      setSystemStatus(prev => ({ ...prev, connected: true }));
    };

    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handleRealtimeUpdate(data);
      } catch (error) {
        console.error('Error parsing SSE data:', error);
      }
    };

    eventSource.onerror = () => {
      setSystemStatus(prev => ({ ...prev, connected: false }));
    };

    return () => {
      eventSource.close();
    };
  }, []);

  // Handle real-time updates from backend
  const handleRealtimeUpdate = (data) => {
    switch (data.type) {
      case 'agent_status':
        setAgents(prev => ({
          ...prev,
          [data.agent]: {
            ...prev[data.agent],
            status: data.status,
            progress: data.progress
          }
        }));
        break;

      case 'message_new':
        setAgents(prev => ({
          ...prev,
          [data.agent]: {
            ...prev[data.agent],
            messages: [...prev[data.agent].messages, data.message]
          }
        }));
        break;

      case 'conflict_detected':
        setActionQueue(prev => [...prev, {
          id: data.id,
          type: 'conflict',
          description: data.description,
          timestamp: new Date(),
          resolved: false
        }]);
        break;

      case 'project_complete':
        setProject(prev => ({ ...prev, status: 'completed' }));
        setFiles(prev => ({ ...prev, generated: data.files }));
        break;

      default:
        console.log('Unknown event type:', data.type);
    }
  };

  // API functions
  const startProject = async (requirements) => {
    try {
      const response = await fetch('/api/projects', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ requirements })
      });

      const data = await response.json();
      setProject({
        id: data.project_id,
        requirements,
        status: 'processing',
        createdAt: new Date()
      });

      return data;
    } catch (error) {
      console.error('Error starting project:', error);
      throw error;
    }
  };

  const resolveAction = async (actionId, resolution) => {
    try {
      await fetch('/api/conflicts/resolve', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action_id: actionId, resolution })
      });

      setActionQueue(prev => 
        prev.map(action => 
          action.id === actionId 
            ? { ...action, resolved: true, resolution }
            : action
        )
      );
    } catch (error) {
      console.error('Error resolving action:', error);
      throw error;
    }
  };

  const value = {
    // State
    project,
    agents,
    actionQueue,
    files,
    systemStatus,

    // Actions
    startProject,
    resolveAction,
    setProject,
    setAgents,
    setActionQueue,
    setFiles
  };

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};
'''

    async def _generate_react_component(self, component_name: str, specs: Dict) -> str:
        \"\"\"Generate React component based on name and specifications.\"\"\"

        prompt = DEVELOPER_PROMPTS[\"react_component\"].format(
            component_name=component_name,
            component_specs=json.dumps(specs, indent=2)
        )

        response = await self.llm_client.generate(
            prompt=prompt,
            max_tokens=1500,
            temperature=0.1
        )

        return response.strip()

    async def _generate_api_utils(self) -> str:
        \"\"\"Generate API utility functions.\"\"\"

        return '''/**
 * API utility functions for BotArmy frontend.
 */

const API_BASE_URL = '';

export class ApiClient {
  constructor() {
    this.baseURL = API_BASE_URL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }

  // Project endpoints
  async createProject(requirements) {
    return this.request('/api/projects', {
      method: 'POST',
      body: JSON.stringify({ requirements }),
    });
  }

  async getProject(projectId) {
    return this.request(`/api/projects/${projectId}`);
  }

  async getProjects() {
    return this.request('/api/projects');
  }

  // Agent endpoints
  async getAgentStatus(projectId, agentType) {
    return this.request(`/api/agents/${projectId}/${agentType}/status`);
  }

  async getAgentMessages(projectId, agentType) {
    return this.request(`/api/agents/${projectId}/${agentType}/messages`);
  }

  // Conflict resolution endpoints
  async getConflicts(projectId) {
    return this.request(`/api/conflicts/${projectId}`);
  }

  async resolveConflict(conflictId, resolution) {
    return this.request(`/api/conflicts/${conflictId}/resolve`, {
      method: 'POST',
      body: JSON.stringify({ resolution }),
    });
  }

  // File endpoints
  async uploadFile(projectId, file) {
    const formData = new FormData();
    formData.append('file', file);

    return this.request(`/api/files/${projectId}/upload`, {
      method: 'POST',
      body: formData,
      headers: {}, // Let browser set Content-Type for FormData
    });
  }

  async downloadFiles(projectId) {
    const response = await fetch(`/api/files/${projectId}/download`);
    return response.blob();
  }

  async getFiles(projectId) {
    return this.request(`/api/files/${projectId}`);
  }

  // System endpoints
  async getSystemStatus() {
    return this.request('/api/system/status');
  }

  async getUsageStats() {
    return this.request('/api/system/usage');
  }
}

// Export singleton instance
export const apiClient = new ApiClient();

// Convenience functions
export const api = {
  projects: {
    create: (requirements) => apiClient.createProject(requirements),
    get: (id) => apiClient.getProject(id),
    list: () => apiClient.getProjects(),
  },
  agents: {
    status: (projectId, agentType) => apiClient.getAgentStatus(projectId, agentType),
    messages: (projectId, agentType) => apiClient.getAgentMessages(projectId, agentType),
  },
  conflicts: {
    list: (projectId) => apiClient.getConflicts(projectId),
    resolve: (conflictId, resolution) => apiClient.resolveConflict(conflictId, resolution),
  },
  files: {
    upload: (projectId, file) => apiClient.uploadFile(projectId, file),
    download: (projectId) => apiClient.downloadFiles(projectId),
    list: (projectId) => apiClient.getFiles(projectId),
  },
  system: {
    status: () => apiClient.getSystemStatus(),
    usage: () => apiClient.getUsageStats(),
  },
};
'''

    async def _generate_formatting_utils(self) -> str:
        \"\"\"Generate formatting utility functions.\"\"\"

        return '''/**
 * Formatting utility functions for BotArmy frontend.
 */

export const formatters = {
  // Date formatting
  date: (date) => {
    if (!date) return 'N/A';
    const d = new Date(date);
    return d.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  },

  // Relative time formatting
  timeAgo: (date) => {
    if (!date) return 'N/A';
    const now = new Date();
    const diff = now - new Date(date);
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
    if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
    return 'Just now';
  },

  // Duration formatting
  duration: (ms) => {
    if (!ms || ms < 0) return '0s';
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
  },

  // File size formatting
  fileSize: (bytes) => {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
  },

  // Number formatting
  number: (num) => {
    if (!num && num !== 0) return 'N/A';
    return new Intl.NumberFormat('en-US').format(num);
  },

  // Percentage formatting
  percentage: (num, decimals = 1) => {
    if (!num && num !== 0) return 'N/A';
    return `${(num * 100).toFixed(decimals)}%`;
  },

  // Currency formatting
  currency: (amount, currency = 'USD') => {
    if (!amount && amount !== 0) return 'N/A';
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency,
    }).format(amount);
  },

  // Agent status formatting
  agentStatus: (status) => {
    const statusMap = {
      idle: { text: 'Idle', color: 'gray' },
      processing: { text: 'Processing', color: 'blue' },
      completed: { text: 'Completed', color: 'green' },
      error: { text: 'Error', color: 'red' },
      waiting: { text: 'Waiting', color: 'yellow' },
    };
    return statusMap[status] || { text: status, color: 'gray' };
  },

  // Progress formatting
  progress: (current, total) => {
    if (!total || total === 0) return '0%';
    const percent = Math.round((current / total) * 100);
    return `${percent}%`;
  },

  // Text truncation
  truncate: (text, maxLength = 100) => {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return `${text.substring(0, maxLength)}...`;
  },

  // Code language detection and formatting
  codeLanguage: (filename) => {
    const ext = filename.split('.').pop()?.toLowerCase();
    const languageMap = {
      py: 'Python',
      js: 'JavaScript',
      jsx: 'React',
      ts: 'TypeScript',
      tsx: 'TypeScript React',
      html: 'HTML',
      css: 'CSS',
      sql: 'SQL',
      md: 'Markdown',
      json: 'JSON',
      yml: 'YAML',
      yaml: 'YAML',
    };
    return languageMap[ext] || 'Text';
  },

  // Token usage formatting
  tokens: (count) => {
    if (!count && count !== 0) return 'N/A';
    if (count < 1000) return `${count} tokens`;
    if (count < 1000000) return `${(count / 1000).toFixed(1)}K tokens`;
    return `${(count / 1000000).toFixed(1)}M tokens`;
  },
};

export const validators = {
  email: (email) => {
    const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
    return re.test(email);
  },

  url: (url) => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  },

  required: (value) => {
    return value !== null && value !== undefined && value !== '';
  },

  minLength: (value, min) => {
    return value && value.length >= min;
  },

  maxLength: (value, max) => {
    return !value || value.length <= max;
  },
};

export const utils = {
  // Generate unique ID
  generateId: () => {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  },

  // Debounce function
  debounce: (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  },

  // Deep clone object
  deepClone: (obj) => {
    return JSON.parse(JSON.stringify(obj));
  },

  // Check if object is empty
  isEmpty: (obj) => {
    return Object.keys(obj).length === 0;
  },

  // Merge objects
  merge: (...objects) => {
    return Object.assign({}, ...objects);
  },
};
'''

    async def _generate_app_css(self) -> str:
        \"\"\"Generate main App CSS file.\"\"\"

        return '''/* Main App CSS */
.App {
  text-align: left;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Loading animations */
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Status indicators */
.status-indicator {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.status-idle { background-color: #6b7280; }
.status-processing { 
  background-color: #3b82f6; 
  animation: pulse 2s infinite;
}
.status-completed { background-color: #10b981; }
.status-error { background-color: #ef4444; }
.status-waiting { background-color: #f59e0b; }

/* Progress bars */
.progress-bar {
  width: 100%;
  height: 8px;
  background-color: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background-color: #3b82f6;
  transition: width 0.3s ease;
}

/* Code syntax highlighting */
.code-block {
  background-color: #1f2937;
  color: #f9fafb;
  padding: 16px;
  border-radius: 8px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 14px;
  line-height: 1.5;
  overflow-x: auto;
}

/* Agent panels */
.agent-panel {
  border: 2px solid transparent;
  transition: all 0.3s ease;
}

.agent-panel:hover {
  border-color: #e5e7eb;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.agent-panel.active {
  border-color: #3b82f6;
  box-shadow: 0 0 0 1px #3b82f6;
}

/* File tree */
.file-tree {
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 14px;
}

.file-tree-item {
  display: flex;
  align-items: center;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.2s ease;
}

.file-tree-item:hover {
  background-color: #f3f4f6;
}

.file-tree-item.selected {
  background-color: #dbeafe;
  color: #1d4ed8;
}

/* Notifications */
.notification {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 16px;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.notification.success {
  background-color: #10b981;
  color: white;
}

.notification.error {
  background-color: #ef4444;
  color: white;
}

.notification.warning {
  background-color: #f59e0b;
  color: white;
}

.notification.info {
  background-color: #3b82f6;
  color: white;
}

/* Responsive design helpers */
@media (max-width: 768px) {
  .hide-mobile {
    display: none;
  }
  
  .mobile-stack {
    flex-direction: column;
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .dark-mode {
    background-color: #1f2937;
    color: #f9fafb;
  }
  
  .dark-mode .bg-white {
    background-color: #374151;
  }
  
  .dark-mode .text-gray-900 {
    color: #f9fafb;
  }
  
  .dark-mode .border-gray-200 {
    border-color: #4b5563;
  }
}
'''

    async def _generate_index_css(self) -> str:
        \"\"\"Generate index CSS file.\"\"\"

        return '''/* Index CSS with Tailwind base styles */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global styles */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f9fafb;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* Custom utility classes */
@layer utilities {
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }
  
  .text-shadow {
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .gradient-text {
    background: linear-gradient(45deg, #3b82f6, #8b5cf6);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
}

/* Component styles */
@layer components {
  .btn-primary {
    @apply bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200;
  }
  
  .btn-secondary {
    @apply bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-lg transition-colors duration-200;
  }
  
  .card {
    @apply bg-white rounded-lg shadow-sm border border-gray-200 p-6;
  }
  
  .input-field {
    @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent;
  }
  
  .badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
  }
  
  .badge-blue {
    @apply bg-blue-100 text-blue-800;
  }
  
  .badge-green {
    @apply bg-green-100 text-green-800;
  }
  
  .badge-red {
    @apply bg-red-100 text-red-800;
  }
  
  .badge-yellow {
    @apply bg-yellow-100 text-yellow-800;
  }
  
  .badge-gray {
    @apply bg-gray-100 text-gray-800;
  }
}
'''

    async def _generate_react_index(self) -> str:
        \"\"\"Generate React index.js file.\"\"\"

        return '''import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
'''

    async def _generate_html_template(self) -> str:
        \"\"\"Generate HTML template.\"\"\"

        return '''<!DOCTYPE html>
<html lang=\"en\">
  <head>
    <meta charset=\"utf-8\" />
    <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />
    <meta name=\"theme-color\" content=\"#000000\" />
    <meta
      name=\"description\"
      content=\"BotArmy - AI-powered software development automation\"
    />
    <title>BotArmy POC</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id=\"root\"></div>
  </body>
</html>
'''

    async def _generate_workflow_pipeline(self) -> str:
        \"\"\"Generate workflow pipeline manager.\"\"\"

        return '''\"\"\"
Workflow pipeline manager for orchestrating agent sequences.
\"\"\"

import asyncio
import json
from typing import Dict, List, Any, Optional
from database import Database

class WorkflowPipeline:
    \"\"\"
    Manages the sequential execution of agents in the BotArmy workflow.
    \"\"\"

    def __init__(self, database: Database, logger):
        self.database = database
        self.logger = logger
        self.agents = {}
        self.current_project = None
        self.pipeline_stages = [
            \"analyst\",
            \"architect\", 
            \"developer\",
            \"tester\"
        ]

    def register_agent(self, agent_type: str, agent_instance):
        \"\"\"Register an agent instance for the pipeline.\"\"\"
        self.agents[agent_type] = agent_instance
        self.logger.info(f\"Registered {agent_type} agent\")

    async def execute_pipeline(self, project_id: str, initial_requirements: str) -> Dict[str, Any]:
        \"\"\"
        Execute the complete agent pipeline for a project.

        Args:
            project_id: Unique project identifier
            initial_requirements: Initial user requirements

        Returns:
            Final pipeline results
        \"\"\"
        try:
            self.current_project = project_id
            self.logger.info(f\"Starting pipeline execution for project {project_id}\")

            # Initialize pipeline state
            pipeline_state = {
                \"project_id\": project_id,
                \"current_stage\": 0,
                \"stage_outputs\": {},
                \"errors\": [],
                \"start_time\": asyncio.get_event_loop().time()
            }

            # Store initial requirements
            await self.database.update_project_status(project_id, \"processing\")
            
            # Execute each stage sequentially
            stage_input = {\"project_id\": project_id, \"requirements\": initial_requirements}

            for stage_index, agent_type in enumerate(self.pipeline_stages):
                pipeline_state[\"current_stage\"] = stage_index
                
                try:
                    self.logger.info(f\"Executing stage {stage_index + 1}: {agent_type}\")
                    
                    # Get agent instance
                    agent = self.agents.get(agent_type)
                    if not agent:
                        raise Exception(f\"Agent {agent_type} not registered\")

                    # Execute agent
                    stage_output = await agent.process(stage_input)
                    
                    # Store stage output
                    pipeline_state[\"stage_outputs\"][agent_type] = stage_output
                    
                    # Prepare input for next stage
                    stage_input = {
                        **stage_input,
                        **stage_output
                    }
                    
                    self.logger.info(f\"Completed stage {stage_index + 1}: {agent_type}\")

                except Exception as e:
                    error_msg = f\"Stage {stage_index + 1} ({agent_type}) failed: {str(e)}\"
                    self.logger.error(error_msg)
                    pipeline_state[\"errors\"].append(error_msg)
                    
                    # Attempt error recovery
                    recovery_success = await self._handle_stage_error(
                        agent_type, stage_input, str(e)
                    )
                    
                    if not recovery_success:
                        await self.database.update_project_status(project_id, \"error\")
                        raise Exception(f\"Pipeline failed at stage {agent_type}: {str(e)}\")

            # Pipeline completed successfully
            pipeline_state[\"end_time\"] = asyncio.get_event_loop().time()
            pipeline_state[\"total_time\"] = (
                pipeline_state[\"end_time\"] - pipeline_state[\"start_time\"]
            )

            await self.database.update_project_status(project_id, \"completed\")
            self.logger.info(f\"Pipeline completed successfully for project {project_id}\")

            return {
                \"success\": True,
                `
}