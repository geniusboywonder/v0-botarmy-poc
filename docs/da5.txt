{
  `content`: `                \"project_id\": project_id,
                \"pipeline_state\": pipeline_state,
                \"final_output\": stage_input
            }

        except Exception as e:
            self.logger.error(f\"Pipeline execution failed: {str(e)}\")
            return {
                \"success\": False,
                \"project_id\": project_id,
                \"error\": str(e),
                \"pipeline_state\": pipeline_state
            }

    async def _handle_stage_error(self, agent_type: str, stage_input: Dict, 
                                error_message: str) -> bool:
        \"\"\"Handle errors in pipeline stages with retry logic.\"\"\"
        
        max_retries = 3
        for attempt in range(max_retries):
            try:
                self.logger.info(f\"Retrying {agent_type} agent (attempt {attempt + 1})\")
                
                # Wait before retry with exponential backoff
                await asyncio.sleep(2 ** attempt)
                
                # Retry agent execution
                agent = self.agents.get(agent_type)
                if agent:
                    await agent.process(stage_input)
                    return True
                    
            except Exception as e:
                self.logger.warning(f\"Retry {attempt + 1} failed for {agent_type}: {str(e)}\")
                continue
                
        # All retries failed
        return False

    async def get_pipeline_status(self, project_id: str) -> Dict[str, Any]:
        \"\"\"Get current pipeline execution status.\"\"\"
        
        agents_status = {}
        for agent_type in self.pipeline_stages:
            agent = self.agents.get(agent_type)
            if agent:
                agents_status[agent_type] = agent.get_status()
            else:
                agents_status[agent_type] = {\"status\": \"not_registered\"}
                
        return {
            \"project_id\": project_id,
            \"agents\": agents_status,
            \"current_project\": self.current_project
        }

    async def pause_pipeline(self, project_id: str):
        \"\"\"Pause pipeline execution.\"\"\"
        # Implementation for pausing pipeline
        pass

    async def resume_pipeline(self, project_id: str):
        \"\"\"Resume paused pipeline execution.\"\"\"
        # Implementation for resuming pipeline
        pass

    async def cancel_pipeline(self, project_id: str):
        \"\"\"Cancel pipeline execution.\"\"\"
        # Implementation for canceling pipeline
        pass
'''

    async def _generate_state_manager(self) -> str:
        \"\"\"Generate state manager for workflow tracking.\"\"\"

        return '''\"\"\"
State manager for tracking workflow and agent states.
\"\"\"

import json
import asyncio
from typing import Dict, List, Any, Optional
from enum import Enum
from database import Database

class AgentStatus(Enum):
    IDLE = \"idle\"
    PROCESSING = \"processing\"
    COMPLETED = \"completed\"
    ERROR = \"error\"
    WAITING = \"waiting\"

class ProjectStatus(Enum):
    CREATED = \"created\"
    PROCESSING = \"processing\"
    COMPLETED = \"completed\"
    ERROR = \"error\"
    CANCELLED = \"cancelled\"

class StateManager:
    \"\"\"
    Manages state for projects, agents, and workflow execution.
    \"\"\"

    def __init__(self, database: Database, logger):
        self.database = database
        self.logger = logger
        self.project_states = {}
        self.agent_states = {}
        self.event_listeners = []

    async def create_project_state(self, project_id: str, requirements: str) -> Dict[str, Any]:
        \"\"\"Create initial state for a new project.\"\"\"
        
        project_state = {
            \"project_id\": project_id,
            \"status\": ProjectStatus.CREATED.value,
            \"requirements\": requirements,
            \"created_at\": asyncio.get_event_loop().time(),
            \"updated_at\": asyncio.get_event_loop().time(),
            \"agents\": {
                \"analyst\": {\"status\": AgentStatus.IDLE.value, \"progress\": 0},
                \"architect\": {\"status\": AgentStatus.IDLE.value, \"progress\": 0},
                \"developer\": {\"status\": AgentStatus.IDLE.value, \"progress\": 0},
                \"tester\": {\"status\": AgentStatus.IDLE.value, \"progress\": 0}
            },
            \"conflicts\": [],
            \"files\": [],
            \"metadata\": {}
        }
        
        self.project_states[project_id] = project_state
        await self.database.create_project(project_id, requirements)
        
        self.logger.info(f\"Created project state for {project_id}\")
        await self._notify_state_change(\"project_created\", project_state)
        
        return project_state

    async def update_project_status(self, project_id: str, status: str, 
                                  metadata: Dict = None) -> bool:
        \"\"\"Update project status and metadata.\"\"\"
        
        if project_id not in self.project_states:
            return False
            
        self.project_states[project_id][\"status\"] = status
        self.project_states[project_id][\"updated_at\"] = asyncio.get_event_loop().time()
        
        if metadata:
            self.project_states[project_id][\"metadata\"].update(metadata)
            
        await self.database.update_project_status(project_id, status)
        
        self.logger.info(f\"Updated project {project_id} status to {status}\")
        await self._notify_state_change(\"project_updated\", self.project_states[project_id])
        
        return True

    async def update_agent_status(self, project_id: str, agent_type: str, 
                                status: str, progress: int = None) -> bool:
        \"\"\"Update agent status and progress.\"\"\"
        
        if project_id not in self.project_states:
            return False
            
        agent_state = self.project_states[project_id][\"agents\"][agent_type]
        agent_state[\"status\"] = status
        agent_state[\"updated_at\"] = asyncio.get_event_loop().time()
        
        if progress is not None:
            agent_state[\"progress\"] = progress
            
        await self.database.update_agent_status(project_id, agent_type, status, progress)
        
        self.logger.info(f\"Updated {agent_type} agent status to {status} ({progress}%)\")
        await self._notify_state_change(\"agent_updated\", {
            \"project_id\": project_id,
            \"agent_type\": agent_type,
            \"status\": status,
            \"progress\": progress
        })
        
        return True

    async def add_conflict(self, project_id: str, description: str, 
                          agents_involved: List[str]) -> str:
        \"\"\"Add a conflict that requires human intervention.\"\"\"
        
        conflict_id = f\"conflict_{len(self.project_states[project_id]['conflicts'])}\"
        conflict = {
            \"id\": conflict_id,
            \"description\": description,
            \"agents_involved\": agents_involved,
            \"created_at\": asyncio.get_event_loop().time(),
            \"resolved\": False,
            \"resolution\": None
        }
        
        self.project_states[project_id][\"conflicts\"].append(conflict)
        await self.database.create_conflict(project_id, conflict_id, description, agents_involved)
        
        self.logger.info(f\"Added conflict {conflict_id} for project {project_id}\")
        await self._notify_state_change(\"conflict_created\", {
            \"project_id\": project_id,
            \"conflict\": conflict
        })
        
        return conflict_id

    async def resolve_conflict(self, project_id: str, conflict_id: str, 
                             resolution: str) -> bool:
        \"\"\"Resolve a conflict with human input.\"\"\"
        
        if project_id not in self.project_states:
            return False
            
        conflicts = self.project_states[project_id][\"conflicts\"]
        for conflict in conflicts:
            if conflict[\"id\"] == conflict_id:
                conflict[\"resolved\"] = True
                conflict[\"resolution\"] = resolution
                conflict[\"resolved_at\"] = asyncio.get_event_loop().time()
                
                await self.database.resolve_conflict(conflict_id, resolution)
                
                self.logger.info(f\"Resolved conflict {conflict_id}\")
                await self._notify_state_change(\"conflict_resolved\", {
                    \"project_id\": project_id,
                    \"conflict\": conflict
                })
                
                return True
                
        return False

    async def add_generated_file(self, project_id: str, filename: str, 
                               content: str, generated_by: str):
        \"\"\"Add a generated file to project state.\"\"\"
        
        file_entry = {
            \"filename\": filename,
            \"content\": content,
            \"generated_by\": generated_by,
            \"created_at\": asyncio.get_event_loop().time(),
            \"size\": len(content)
        }
        
        self.project_states[project_id][\"files\"].append(file_entry)
        await self.database.save_file(project_id, filename, content, generated_by)
        
        self.logger.info(f\"Added generated file {filename} to project {project_id}\")

    def get_project_state(self, project_id: str) -> Optional[Dict[str, Any]]:
        \"\"\"Get current project state.\"\"\"
        return self.project_states.get(project_id)

    def get_agent_state(self, project_id: str, agent_type: str) -> Optional[Dict[str, Any]]:
        \"\"\"Get current agent state.\"\"\"
        project_state = self.project_states.get(project_id)
        if project_state:
            return project_state[\"agents\"].get(agent_type)
        return None

    def get_pending_conflicts(self, project_id: str) -> List[Dict[str, Any]]:
        \"\"\"Get all pending conflicts for a project.\"\"\"
        project_state = self.project_states.get(project_id)
        if project_state:
            return [c for c in project_state[\"conflicts\"] if not c[\"resolved\"]]
        return []

    async def register_event_listener(self, callback):
        \"\"\"Register a callback for state change events.\"\"\"
        self.event_listeners.append(callback)

    async def _notify_state_change(self, event_type: str, data: Dict[str, Any]):
        \"\"\"Notify all registered listeners of state changes.\"\"\"
        for listener in self.event_listeners:
            try:
                await listener(event_type, data)
            except Exception as e:
                self.logger.error(f\"Error in event listener: {str(e)}\")

    async def cleanup_old_projects(self, max_age_hours: int = 24):
        \"\"\"Clean up old project states to prevent memory leaks.\"\"\"
        current_time = asyncio.get_event_loop().time()
        max_age_seconds = max_age_hours * 3600
        
        projects_to_remove = []
        for project_id, state in self.project_states.items():
            if current_time - state[\"created_at\"] > max_age_seconds:
                projects_to_remove.append(project_id)
                
        for project_id in projects_to_remove:
            del self.project_states[project_id]
            self.logger.info(f\"Cleaned up old project state: {project_id}\")

    def get_system_stats(self) -> Dict[str, Any]:
        \"\"\"Get system-wide statistics.\"\"\"
        total_projects = len(self.project_states)
        
        status_counts = {}
        for state in self.project_states.values():
            status = state[\"status\"]
            status_counts[status] = status_counts.get(status, 0) + 1
            
        return {
            \"total_projects\": total_projects,
            \"status_counts\": status_counts,
            \"memory_usage\": len(str(self.project_states))
        }
'''

    async def _perform_quality_checks(self, backend_files: Dict, frontend_files: Dict, 
                                    config_files: Dict) -> Dict:
        \"\"\"Perform basic quality checks on generated code.\"\"\"

        issues = []
        warnings = []

        # Check for required files
        required_backend = [\"main.py\", \"database.py\", \"config.py\"]
        required_frontend = [\"src/App.jsx\", \"package.json\"]
        required_config = [\"requirements.txt\", \".env.example\"]

        for file in required_backend:
            if file not in backend_files:
                issues.append(f\"Missing required backend file: {file}\")

        for file in required_frontend:
            if file not in frontend_files:
                issues.append(f\"Missing required frontend file: {file}\")

        for file in required_config:
            if file not in config_files:
                issues.append(f\"Missing required config file: {file}\")

        # Basic syntax checks (simplified)
        for filename, content in backend_files.items():
            if filename.endswith('.py'):
                if 'import' not in content:
                    warnings.append(f\"Python file {filename} may be missing imports\")
                if 'def ' not in content and 'class ' not in content:
                    warnings.append(f\"Python file {filename} may be missing functions/classes\")

        # Security checks
        security_issues = []
        for filename, content in {**backend_files, **frontend_files}.items():
            if 'password' in content.lower() and 'hash' not in content.lower():
                security_issues.append(f\"Potential hardcoded password in {filename}\")
            if 'api_key' in content and 'env' not in content.lower():
                security_issues.append(f\"Potential hardcoded API key in {filename}\")

        return {
            \"issues\": issues,
            \"warnings\": warnings,
            \"security_issues\": security_issues,
            \"total_files\": len(backend_files) + len(frontend_files) + len(config_files),
            \"quality_score\": self._calculate_quality_score(issues, warnings, security_issues),
            \"recommendations\": self._generate_quality_recommendations(issues, warnings)
        }

    def _calculate_quality_score(self, issues: List, warnings: List, security_issues: List) -> float:
        \"\"\"Calculate overall quality score.\"\"\"
        total_problems = len(issues) + len(warnings) + len(security_issues) * 2
        if total_problems == 0:
            return 1.0
        return max(0.0, 1.0 - (total_problems * 0.1))

    def _generate_quality_recommendations(self, issues: List, warnings: List) -> List[str]:
        \"\"\"Generate recommendations based on quality issues.\"\"\"
        recommendations = []

        if issues:
            recommendations.append(\"Address critical issues before deployment\")
        if warnings:
            recommendations.append(\"Review warnings for potential improvements\")
        if not issues and not warnings:
            recommendations.append(\"Code quality looks good - ready for testing\")

        return recommendations

    # Configuration file generation methods

    async def _generate_requirements_txt(self) -> str:
        \"\"\"Generate Python requirements file.\"\"\"

        prompt = DEVELOPER_PROMPTS[\"generate_requirements\"]
        response = await self.llm_client.generate(
            prompt=prompt,
            max_tokens=500,
            temperature=0.1
        )

        return response.strip()

    async def _generate_package_json(self, tech_stack: Dict) -> str:
        \"\"\"Generate Node.js package.json file.\"\"\"

        prompt = DEVELOPER_PROMPTS[\"generate_package_json\"].format(
            tech_stack=json.dumps(tech_stack, indent=2)
        )

        response = await self.llm_client.generate(
            prompt=prompt,
            max_tokens=800,
            temperature=0.1
        )

        return response.strip()

    async def _generate_env_template(self) -> str:
        \"\"\"Generate environment variables template.\"\"\"

        return '''# BotArmy Environment Configuration

# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here
OPENAI_MODEL=gpt-4o-mini
OPENAI_MAX_TOKENS=2000
OPENAI_TEMPERATURE=0.2

# Database Configuration  
DATABASE_URL=sqlite:///./data/messages.db

# Application Configuration
APP_NAME=BotArmy
APP_VERSION=1.0.0
DEBUG=false

# Logging Configuration
LOG_LEVEL=INFO
LOG_FILE=./data/logs/app.log

# Replit Configuration (if using Replit)
REPLIT_DB_URL=

# Security
SECRET_KEY=your_secret_key_here
'''

    async def _generate_replit_config(self) -> str:
        \"\"\"Generate Replit configuration file.\"\"\"

        return '''{ pkgs }: {
  deps = [
    pkgs.nodejs-18_x
    pkgs.python310Full
    pkgs.pip
    pkgs.sqlite
  ];
  
  env = {
    PYTHON_LD_LIBRARY_PATH = pkgs.lib.makeLibraryPath [
      pkgs.sqlite
    ];
  };
}
'''

    async def _generate_replit_file(self) -> str:
        \"\"\"Generate .replit configuration file.\"\"\"

        return '''modules = [\"python-3.10\", \"nodejs-18\"]

[nix]
channel = \"stable-22_11\"

[deployment]
run = [\"python\", \"main.py\"]

[[ports]]
localPort = 8000
externalPort = 80

[env]
PYTHON_LD_LIBRARY_PATH = \"/nix/store/2vpxdyyg4j6p7xb8qb6gy3g5pmbzqzhz-sqlite-3.39.4/lib\"
'''

    async def _generate_vite_config(self) -> str:
        \"\"\"Generate Vite configuration for React.\"\"\"

        return '''import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true
      }
    }
  },
  build: {
    outDir: '../static',
    emptyOutDir: true
  }
})
'''

    async def _generate_gitignore(self) -> str:
        \"\"\"Generate .gitignore file.\"\"\"

        return '''# Dependencies
node_modules/
__pycache__/
*.py[cod]
*$py.class

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
env/
ENV/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.db
*.sqlite
*.sqlite3

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
static/
build/
dist/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Replit
.replit
replit.nix

# Data directory
data/

# Temporary files
tmp/
temp/
'''

    # Documentation generation`
}